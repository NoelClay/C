1. 변수는 메모리를 차지한다.

2. 상수에는 리터럴 상수와 심볼릭 상수가 있다.

3. 리터럴 상수는 컴파일 과정에서 변수에 할당되면 변수의 메모리 공간에 들어간다.

4. 이때 문자열 리터럴은 차이가 있는데 컴파일과정에서 변수의 메모리 공간에 들어가는건 문자열 리터럴 포인터의 주소값이고, 
그 소스에 사용된 문자열 리터럴은 전부 메모리 한구석(읽기 전용 메모리 영역)에 저장되어있다.

5. 심볼릭 상수에는 형한정자로 하는 방법과 전처리기로 하는 방법 2가지가 존재한다. 
형한정자 const로 하는 방법은 읽기전용 변수를 사용하므로 메모리를 차지한다. 
전처리기로 하는방법은 마치 변수처럼 고유한 식별네임을 가지지만, 
컴파일단계에서 그냥 리터럴 상수랑 다를바 없이 치환되어 적용하여 빌드한다.

6. 자료형 종류 : 정수형, 실수형, 유도형, 함수형, void
정수형은 그냥 정수다. 복잡한 소수점을 나타낼 필요가 없는 모든 형태이다. 문자도 정수형, 따라서 문자열도 정수형 배열
실수형은 부동소수점을 이용한 데이터 표현을 하기위해 만들어진 형태이다. 비트부호부 지수부 가수부로 표현

유도형은 기본 자료형으로부터 파생된 자료형. 배열, 포인터, 구조체, 공용체 등등. 
유도형은 메모리에 접근하여 다양한 자료형을 해석한다는 점이 특징.
포인터도 마찬가지고, 구조체도 정의따라 접근한 주소를 탐색하며 데이터를 사용할 수 있고, 구조체 유니언도 마찬가지 맥락

함수형은 포인터와 동일하게 메모리 주소를 저장하지만, 파생된 자료형이라기 보다는 좀 더 복잡한 방식으로 작동함.
그냥 데이터만 저장된게 아니라, 로직이 존재하는 코드이기때문에 호출자의 매개변수 등 더 복잡한 해석이 들어감.
유도형과 마찬가지로 함수형식이름 유도형식이름은 그 자체는 메모리 주소를 저장하지만, 선언한 의도가 다르기 때문에 구분함.


7. 보수로 뺄셈 계산
컴퓨터는 무조건 덧셈만 한다. 뺄셈은 보수형으로 바꾼뒤에 더하는 것. 보수로 바꾼 뒤에 더하면 
무조건 자리올림이 일어나는데 그건 어차피 버림

8. 실수형은 사용하기 전에 표현 범위 정도를 알고 있어서 오차나 범위 이탈을 조심하자.

9. 배열은 공통된 인스턴스가 모인 집합체이다. 배열명은 포인터 처럼 메모리의 주소를 가지고 있고,
각각의 인스턴스에 접근하는 방법은 배열명[인덱스] 이다. 문자열의 끝은 항상 널값.  
