<메모리와 포인터>

1.메모리의 종류
	1. stack : 임시 저장공간,썼다 지웠다 반복하는 공간, 지역변수, 자동변수 들이 사용하며, 함수 호출 함수 탈출
	때마다 빠르게 쓰고 빠르게 지워진다. 자동으로 메모리가 명확하게 관리됨.
	
	2. Heap : 사용자 정의 공간. 지역변수와 달리 동적으로 할당하여 필요한 만큼 가져오기 위해 굉장히 넓은 공간을 쓰며
	free() 호출하지 않는이상 평생 메모리를 쓴다.
	
	3. 실행파일 정의 구역
		1. Text Section : 소스 코드를 기계어로 번역된 공간이며, 기계어가 번역되어 있어 텍스트 섹션이라고 하는듯. 읽기전용
		2. Data Section : 스택 힙처럼 변수들을 사용하는 공간이다
			1. Read Only : 프로그램에서 사용하는 문자열같은 애들이 저장되어 있는 공간이 여기다.
			문자열을 포인터에 할당하면, 이 리드온리 영역에 문자열 올려놓고 주소를 참조한다.
			2. can write : 정적 변수나 전역 변수 들이 여기에 있다. 프로그램이 끝날때까지 이 자식들은 살아있다.
			
2. 포인터 변수의 선언방법은 간접지정연산자와 함께 포인터임을 지정한다.
포인터 변수에 대입하는 값은 주소값이어야 한다. 그리고 그 주소를 어떻게 해석할지는 포인터 변수 선언부에서 정한다.

3. 배열의 이름은 주소이다. 

4. 포인터변수에 1을 증가시키면 주소값에 그냥 1이 추가되는게 아니라, 다음 인덱스를 참조하는것 마냥
포인터 변수의 간접지정 선언을 참고하여 그 길이만큼 주소값이 추가된다. char형이면 1바이트 int형이면 4바이트 길이만큼 +된
주소값으로 대입된다.

5. 메모리 동적할당
int *p = (int*)malloc(size)
int *p = (int*)calloc(할당 갯수, sizeof(자료형));


11-01 중대한 오류 고치기
첫번째 동적할당으로 힙영역을 12바이트나 확보한 주제에 하는 짓이 고작 문자배열의 주소상수값을 복사해서 붙여넣기 한 것뿐입니다.
이럴거면 도적할당 할 필요도 없이 그냥 주소상수값만 가리키는 포인터 하면 됩니다.

두번째 동적할당을 했으면 free()함수로 반환해줘야 합니다.


11-02 문자열과 상대주소 계산
Y				->배열의 첫글자
a				-> 포인터에 배열의 4번째 주소를 할당했으니까
g				-> 4번째 주소 +6은 10인덱스
are a girl		-> 인덱스4 부터 문자열
are a girl		-> 이미 선언 초기화 단계부터 인덱스4의 주소를 복사했음
a girl			-> 거기에 4를 더하니 8번째 인덱스4

