<메모리와 포인터>

1.메모리의 종류
	1. stack : 임시 저장공간,썼다 지웠다 반복하는 공간, 지역변수, 자동변수 들이 사용하며, 함수 호출 함수 탈출
	때마다 빠르게 쓰고 빠르게 지워진다. 자동으로 메모리가 명확하게 관리됨.
	
	2. Heap : 사용자 정의 공간. 지역변수와 달리 동적으로 할당하여 필요한 만큼 가져오기 위해 굉장히 넓은 공간을 쓰며
	free() 호출하지 않는이상 평생 메모리를 쓴다.
	
	3. 실행파일 정의 구역
		1. Text Section : 소스 코드를 기계어로 번역된 공간이며, 기계어가 번역되어 있어 텍스트 섹션이라고 하는듯. 읽기전용
		2. Data Section : 스택 힙처럼 변수들을 사용하는 공간이다
			1. Read Only : 프로그램에서 사용하는 문자열같은 애들이 저장되어 있는 공간이 여기다.
			문자열을 포인터에 할당하면, 이 리드온리 영역에 문자열 올려놓고 주소를 참조한다.
			2. can write : 정적 변수나 전역 변수 들이 여기에 있다. 프로그램이 끝날때까지 이 자식들은 살아있다.
			
2. 포인터 변수의 선언방법은 간접지정연산자와 함께 포인터임을 지정한다.
포인터 변수에 대입하는 값은 주소값이어야 한다. 그리고 그 주소를 어떻게 해석할지는 포인터 변수 선언부에서 정한다.

3. 배열의 이름은 주소이다. 

4. 포인터변수에 1을 증가시키면 주소값에 그냥 1이 추가되는게 아니라, 다음 인덱스를 참조하는것 마냥
포인터 변수의 간접지정 선언을 참고하여 그 길이만큼 주소값이 추가된다. char형이면 1바이트 int형이면 4바이트 길이만큼 +된
주소값으로 대입된다.

5. 메모리 동적할당
int *p = (int*)malloc(size)
int *p = (int*)calloc(할당 갯수, sizeof(자료형));


11-01 중대한 오류 고치기
첫번째 동적할당으로 힙영역을 12바이트나 확보한 주제에 하는 짓이 고작 문자배열의 주소상수값을 복사해서 붙여넣기 한 것뿐입니다.
이럴거면 도적할당 할 필요도 없이 그냥 주소상수값만 가리키는 포인터 하면 됩니다.

두번째 동적할당을 했으면 free()함수로 반환해줘야 합니다.


11-02 문자열과 상대주소 계산
Y				->배열의 첫글자
a				-> 포인터에 배열의 4번째 주소를 할당했으니까
g				-> 4번째 주소 +6은 10인덱스
are a girl		-> 인덱스4 부터 문자열
are a girl		-> 이미 선언 초기화 단계부터 인덱스4의 주소를 복사했음
a girl			-> 거기에 4를 더하니 8번째 인덱스4


6. 다차원 배열과 다차원 포인터

[일차원 배열과 일차원 포인터]
먼저 포인터변수는 주소를 담는 공간과 그 주소로 접근해서 어떻게 해석할지에 대한 처리까지 정읟된 변수라는 사실
그 다음 배열변수는 요소변수들을 정의된 인덱스의 개수만큼 가지고 있다는 사실.
배열변수의 이름은 첫번째 요소변수의 주소값이라는 사실. 그리고 그 배열 변수를 처음 선언처리할때 첫번째 주소는 고정 상수 값이된다는 사실.
	
아까 배운 포인터 변수는 주소값을 저장할 수 있으므로, 배열변수의 이름을 가져와(주소상수) 포인터 변수(주소변수)에 대입할수 있다는 사실
배열 선언 방법 char carr[12] = {0}; 이때 carr은 배열 이름 char는 요소 자료형 [12]는 총 인덱스의 길이. 3가지가 합쳐져 배열선언자가됨.
포인터 선언 방법 char *pchar = carr; char는 포인터 주소로 접근하여 어떻게 해석할지, 그리고 다음값을 해석할때는 얼만큼 이동하면 될지 등
을 정의하는 자료형. * 는 이하 변수이름은 포인터변수의 이름이다 라는 뜻. carr은 주소상수를 가져와서 주소변수인 포인터 변수에 할당함.
굳이 설명하자면, carr = carr2 이건 허용되지 않음. 주소상수인 포인터의 이름에 직접 대입한다? ㄴㄴ. *pchar = carr2 || *pchar = ".." 이건 허용.

[포인터의 배열과 다차원 포인터]
포인터의 배열을 선언하는 방법  char *pArray[3] = {"123","456","789"}; char(주소의 내부값이 char형인) *pArray(포인터의) [3](배열)
각문자열 123 456 789 는 각기 다른 임의의 주소에 저장되어 있다. 그 주소상수값을 각각 *pArray[] 요소에 저장을 한다. 
가능하다. 주소값 저장하는게 포인터변수니까 이제 그 포인터주소를 저장한 문자열을 해석하기 위해서는 아래 코드를 참고

#include <stdio.h>

int main()
{
    char *pArray[3] = {"123","456","789"};
    
    puts(pArray[0]);
    printf("%s\n", pArray[1]);
    
    char *pChartemp = pArray[2];
    
    for(int i=0; *(pChartemp+i) != 0; i++)
    {        
        putchar(*(pChartemp+i));
    }
    
    return 0;
}

기본적으로 puts 나 printf %s 는 전부 매개변수로 일반 자료형을 받는게 아니라 주소값을 받은다음에 널이 나올때까지 출력하는 함수임.
반면 putchar는 주소값을 그대로 전달하는게 아니라 *(주소값)의 형태로 그 내부 원형 데이터를 매개변수로 전달해줘야됨. 
즉 포인터변수가 반환하는 주소값에 간접지정연산자 *를 앞에 붙이면 그 주소안에 있는 데이터를 반환한다. 
왜 굳이 포인터변수가 반환하는 주소값이라고 어렵게 말하냐면 *(pChartemp+i) 이것 때문이다. i가 인덱스이고 더한만큼 char형의 길이만큼 이동하여 주소값을 반환하는데
*pChartemp + i 라고 해버리면 pChartemp의 간접지정연산자로 문자를 하나 가져온다음에 i를 더한 데이터가 만들어져 의도대로 돌아가질 않는다.

문자열이 아니라 int형이라면 *포인터변수명 으로 반환값을 불러와 줬어야됨.

선언 char *pchar		간접지정연산 결과 	*(pchar) == char
선언 char ***pppchar	간접지정연산 결과 	**(pppchar) == char*
*(char** + i) 는 (이중 포인터의 다음 값)에 데이터로 접근한다. 즉 char*가 나올것이다. char* + i 는 char자료형의 크기만큼 다음 인덱스로 넘어간다.


#include <stdio.h>
#include <stdlib.h>

int main() {
    char sarray[3][4];  // 3행 4열의 2차원 배열
    char **ppchar;   

    // ppchar를 위한 메모리 할당
    ppchar = malloc(3 * sizeof(char*));

    // ppchar의 각 요소를 sarray의 각 행에 매핑
    for (int i = 0; i < 3; i++) {
        ppchar[i] = sarray[i];
    }

    // 사용 예시: ppchar을 통해 sarray의 요소에 접근
    ppchar[1][2] = 'a';  // 예: sarray[1][2]에 'a' 저장

    // 사용 후 ppchar 메모리 해제
    free(ppchar);

    return 0;
}


char sarray[3][4];  // 3행 4열의 2차원 배열
char *ppchar[3];    // 3개의 char* 포인터를 가진 배열

for (int i = 0; i < 3; i++) {
    ppchar[i] = sarray[i];  // 각 포인터가 sarray의 각 행을 가리키도록 설정
}


char sarray[3][4] = {{'1','2','3',0},{'4','5','6',0},{'7','8','9',0}};
char* sarray2[3] = { "123","456","789"};

접근해서 가져오는 값은 똑같아도, char형 2차원 배열은 연속적인 메모리공간에 정해진 길이만큼 저장하여 char값이 실려 있고,

char*형 배열의 경우에는 불연속적인 메모리공간의 주소를 단지 배열형에 저장되어 있다는 소리인가? 

즉 sarray2[0] 은 주소값이고 sarray2[1]도 주소값인데 이는 4바이트 크기만큼 차이가 나는 연속적인 주소값이 아니고, 임의의 주소값이고

&sarray[0][0]와 &sarray[1][0]은 역시나 주소값인데 4바이트 크기만큼 차이가나는 연속적인 주소값이다.


7. c언어의 기억부류 지정자 예약어 auto static extern register

auto는 c++과 동작이 많이 다른 예약어, 예약어가 없으면 전부 auto이다. 임시변수 스택이다.

static으로 만들어진건 정적변수 전역변수처럼 프로그램이 끝날때까지 초기화와 해제를 시키지 않는다. 한번 선언 초기화가 된 식별자는
또 같은 식별자로 선언문을 호출해도 선언 초기화가 일어나지 않고 무시됨.
전역변수와 차이는 static은 정의가 되어 있는 범위 안에서만 읽고쓰기가 가능하는 것이다. 함수를 탈출해도, 스코프를 벗어나도 사라지진 않지만,
정의가 되어 있지 않는 영역에서는 접근을 막는 느낌이다.

register 키워드는 CPU의 레지스터 공간에 할당을 하는 변수이다. 메모리와달리 cpu의 레지스터는 컴파일러에게 주소로 접근가능한 연산 
&연사자를 제공하지 않습니다. 고유명사로 식별되어 집니다.

extern 예약어는 다른 소스파일에서 선언된 전역 변수나 함수에 대한 참조라는걸 선언할때 사용된다. 일반 변수에는 사용하질 않습니다.
일반 변수는 static이든 어쩌든 간에 선언된 스코프를 빠져나가는 순간 참조 자체가 안되기 때문. 함수는 그 자체가 스코프이기 때문에 가능.
extern 예약어로 선언되는 변수는 다른 파일에서 정의되어 있는 것이어야 합니다.
다중 파일 프로그램에서 없어서는 안되는 예약어

