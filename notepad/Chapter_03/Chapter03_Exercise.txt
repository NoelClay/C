
1)
#include <stdio.h>

int main()
{
    printf("입력 : ");
    char sInput[300] = {0};
    scanf("%s", sInput);
    getchar ();
    printf("출력 : %c ", sInput[1]);

    return 0;
}

2)
int getchar() 이 좌식은 입력버퍼가 비워져 있다면 문자를 하나 받기 위해서 입력완료를 기다리고, 
입력완료 신호가 오면(Enter) 그때부터 대기를 종료하고 입력버퍼에서 문자 하나를 꺼내서 반환함.
만약 문장을 입력했으면 첫빠따 말고는 전부 입력버퍼에 존재하는 상황 됨.
혹은 scanf로 입력을 받았다면, scanf의 종료 신호도 enter라서 개행문자가 남게된다. 
이때 getchar를 반환하면 입력대기가 아니라 버퍼에 있던 개행문자 반환함.

_getch()는 입력 버퍼 따위 개나주고 일단 콘솔에서 새입력을 무조건 받도록 하는 함수이다.
끝점이 명확하기에 입력완료 엔터키를 기다릴 필요도 없다.

3) gets() 함수는 메모리 오버 결함이 있다. 이를 방지하는게
gets_s(버퍼주소, 버퍼크기)
char* fgets(char* str, int num, FILE* file); 여기도 int num으로 오버 방지하는게
scanf("%99s", buffer); 이런식으로 %99와 같이 길이를 제한하는 방법
scanf_s("%s", buffer, 16);  이런식으로 스캔에프 에스 사용하는 방법

4) 부호비트를 표현하는 식의 특징은 맨앞 비트가 부호라서 0이면 양수 1이면 음수가됨. 
그런데 이때 0111 + 1 을 더하면 1000 이 되어버림 이좌식은 가장 작은 음수임. -1은 1111 임.
1111 + 0001 은 (1) 0000 으로 0됨. 부호비트와 내림차순 정렬은 보수 개념을 다이렉트로 적용하기 위함임.

5) unsigned 는 %u normal integer is %d

6) 123.45는 실수 double형
%lf 

7) %012.3F
0으로 꽉채워서 12자리 공간에 수를 표현하고, 소수점 4번째에서 반올림하여 표현한다.

8) %s

9) 개행문자 하나니까 그냥 getchar() 한번 호출하고 버림.
fflush(stdin);
scanf("%d%*c", &intInput) 로 입력을 받으면 개행문자가 들어오면 그냥 버리고 입력종료함.

10) 스캔에프는 메모리의 주소값을 참조한다. 이렇게 한이유는 자료형에 구애받지 않고, 입력을 받기 위함이다.

11) %lf

